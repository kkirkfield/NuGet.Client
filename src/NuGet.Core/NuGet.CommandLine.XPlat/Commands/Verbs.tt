<#@ template debug="false" hostspecific="true" language="C#" #>
<#@ assembly name="System.Xml.XDocument" #>
<#@ assembly name="System.Xml.Linq" #>
<#@ assembly name="System.Xml" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Globalization" #>
<#@ import namespace="System.Xml.Linq" #>
<#@ import namespace="System.Linq" #>

<#@ include file="Utils.tt" #>
<#@ output extension=".cs" #>
<#
 string commandFile = this.Host.ResolvePath("Commands.xml");
 XDocument commands = XDocument.Load(commandFile);
#>
// Copyright (c) .NET Foundation. All rights reserved.
// Licensed under the Apache License, Version 2.0. See License.txt in the project root for license information.

// Do not manually edit this autogenerated file:
// instead modify the neighboring .tt file (text template) and/or NuGet.CommandLine.Xplat\Commands\Commands.xml (data file),
// then re-execute the text template via "run custom tool" on VS context menu for .tt file, or via dotnet-t4 global tool.

using System;
using System.CommandLine;
using System.CommandLine.NamingConventionBinder;
using NuGet.Commands;
using NuGet.Common;

namespace NuGet.CommandLine.XPlat
{
<#
// ********************** Verb-Parser Template
foreach (XElement verb in commands.Descendants(XName.Get("Verb","")))
{
    string commandName = verb.Attribute(XName.Get("Name", "")).Value;
    string commandFormalName = InitCaps(commandName);
    string commandFormalNameVar = commandFormalName + "Cmd";
#>
    internal partial class <#= commandFormalName #>VerbParser
    {
        internal static void Register(Command app, Func<ILogger> getLogger)
        {
            var <#= commandFormalNameVar #> = new Command(name: "<#= commandName #>", description: Strings.<#= commandFormalName #>_Description);

            // Options directly under the verb '<#= commandName #>'
<#
    GenerateAddOptionOrArgument(verb, commandFormalNameVar, 12);

    foreach (XElement noun in verb.Descendants(XName.Get("Noun")))
    {
        string nounName = noun.Attribute(XName.Get("Name", ""))?.Value;
        string nounFormalName = InitCaps(nounName).Replace("-", "");
        string nounFormalNameVar = nounFormalName + "Cmd";
        if (nounFormalName == null)
        {
            throw new ArgumentException("nounFormalName cannot be null");
        }
#>

            // noun sub-command: <#= commandName #> <#= nounName #>
            var <#= nounFormalNameVar #> = new Command(name: "<#= nounName #>", description: Strings.<#= commandFormalName #><#= nounFormalName #>CommandDescription);

            // Options under sub-command: <#= commandName #> <#= nounName #>
<#
        // Look for options directly under each noun
        GenerateAddOptionOrArgument(noun, nounFormalNameVar, 12);

        // Generate handler for noun
        GenerateCommandHandler(nounFormalNameVar, commandFormalName + nounFormalName, noun, 12);

#>
            <#= commandFormalNameVar #>.AddCommand(<#= nounFormalNameVar #>);
<#

    } // end noun foreach

    var opts = verb.Elements().Where(n => isValidOption(n));

    // Generate handler for verb
    if (opts.Any())
    {
        //GenerateCommandHandler(commandFormalNameVar, commandFormalName, verb, 12);
    }
#>

            app.AddCommand(<#= commandFormalNameVar #>);
        } // End noun method
    } // end class

<#
} // end verb foreach
#>
} // end namespace
