<#@ template debug="false" hostspecific="true" language="C#" #>
<#@ assembly name="System.Xml.XDocument" #>
<#@ assembly name="System.Xml.Linq" #>
<#@ assembly name="System.Xml" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Globalization" #>
<#@ import namespace="System.Xml.Linq" #>
<#@ import namespace="System.Linq" #>
<#@ output extension=".cs" #>
<#
 string commandFile = this.Host.ResolvePath("Commands.xml");
 XDocument commands = XDocument.Load(commandFile);
#>
// Copyright (c) .NET Foundation. All rights reserved.
// Licensed under the Apache License, Version 2.0. See License.txt in the project root for license information.

// Do not manually edit this autogenerated file:
// instead modify the neighboring .tt file (text template) and/or NuGet.CommandLine.Xplat\Commands\Commands.xml (data file),
// then re-execute the text template via "run custom tool" on VS context menu for .tt file, or via dotnet-t4 global tool.

using System;
using System.CommandLine;
using NuGet.Commands;
using NuGet.Common;

namespace NuGet.CommandLine.XPlat
{
<#
// ********************** Verb-Parser Template
foreach (XElement verb in commands.Descendants(XName.Get("Verb","")))
{
    string commandName = verb.Attribute(XName.Get("Name", "")).Value;
    string commandFormalName = StringUtilities.InitCaps(commandName);
#>
    internal partial class <#= commandFormalName #>VerbParser
    {
        internal static void Register(Command app, Func<ILogger> getLogger)
        {
            var <#= commandFormalName #>Cmd = new Command("<#= commandName #>");

<#
    // Look for options directly under the verb
    foreach (XElement option in verb.Descendants())
    {
        if (option.Name == XName.Get("Noun"))
        {
            break;
        }

        var data = new OptionData(option);
        if (data.BaseClass == "Argument")
        {
#>
            <#= commandFormalName #>Cmd.AddArgument(new Argument<object>("<#= data.LongNameOrName #>"));
<#
        }
        else if (data.BaseClass == "Option")
        {
#>
            var <#= data.FormalName #>Option = new Option<object>("<#= data.LongNameOrName #>", description: <#= data.Help #>);
            <#= data.FormalName #>Option.Arity = <#= data.OptionType #>;
            <#= commandFormalName #>Cmd.AddOption(<#= data.FormalName #>Option);
<#
        }
    }

    foreach (XElement noun in verb.Descendants(XName.Get("Noun")))
    {
        string nounName = noun.Attribute(XName.Get("Name", ""))?.Value;
        string nounFormalName = StringUtilities.InitCaps(nounName);
        nounFormalName = nounFormalName.Replace("-", "");
        if (nounFormalName != null)
        {
#>
            var <#= nounFormalName #>Cmd = new Command(name: "<#= nounName #>", description: Strings.<#= commandFormalName #><#= nounFormalName #>CommandDescription);
<#
        }

        // Look for options directly under each noun
        foreach (XElement option in noun.Descendants())
        {
            var data = new OptionData(option);
            if (data.BaseClass == "Argument")
            {
#>
            var <#= data.FormalName #>Arg = new Argument<object>(name: "<#= data.LongNameOrName #>", description: <#= data.Help #>);
            <#= nounFormalName #>Cmd.AddArgument(<#= data.FormalName #>Arg);
<#
            }
            else if (data.BaseClass == "Option")
            {
                if (data.HasShortcut)
                {
#>
            var <#= data.FormalName #>Option = new Option<object>(aliases: new[] { "<#= data.ShortcutName #>", "<#= data.FullName #>" }, description: <#= data.Help #>)
<# 
                }
                else
                {
#>
            var <#= data.FormalName #>Option = new Option<object>(name: "<#= data.FullName #>", description: <#= data.Help #>)
<#
                }
#>
            {
                Arity = <#= data.OptionType #>,
            };
            <#= nounFormalName #>Cmd.AddOption(<#= data.FormalName #>Option);
<#
            }
        }
#>

            <#= nounFormalName #>.AddHandler();

                    // <#= nounFormalName #>Cmd.HelpOption("-h|--help");
                    <#= nounFormalName #>Cmd.OnExecute(() =>
                    {
                        var args = new <#= commandFormalName #><#= nounFormalName #>Args()
                        {
<#
        foreach (XElement option in noun.Descendants())
        {
            var data = new OptionData(option);
            if (data.BaseClass == "Argument")
            {
#>
                            <#= data.InitCapsName #> = <#= data.FormalName #>.Value,
<#
            }
            else if (data.BaseClass == "Option")
            {
                switch (data.OptionType)
                {
                    case "SingleValue":
#>
                            <#= data.InitCapsName #> = <#= data.FormalName #>.Value(),
<#
                        break;
                    case "NoValue":
#>
                            <#= data.InitCapsName #> = <#= data.FormalName #>.HasValue(),
<#
                        break;
                }
            }
        }
#>
                        };

<#  // ****** IMPLEMENT REQUIRED ARGUMENTS ********

            foreach (XElement option2 in noun.Descendants())
            {
                var optionData = new OptionData(option2);
                if (optionData.IsRequired)
                {
                    if (optionData.BaseClass == "Argument")
                    {
#>
                    if (args.<#= optionData.InitCapsName #> == null)
                    {
                        throw new CommandException("'<#= optionData.FormalName #>' argument is missing but required.");
                    }
<#
                    }
                    else if (optionData.BaseClass == "Option")
                    {
                        switch (optionData.OptionType)
                        {
                        case "SingleValue":
#>
                        if (args.<#= optionData.InitCapsName #> == null)
                        {
                            throw new CommandException("'<#= optionData.FormalName #>' option is missing but required.");
                        }
<#
                                break;
                            case "NoValue":
#>
                        //TODO: implement required for bool
<#
                                break;
                        }
                    }
                }
            }
#>
                        <#= commandFormalName #><#= nounFormalName #>Runner.Run(args, getLogger);
                        return 0;
                    });
                });
<#
        }
#>
                <#= commandFormalName #>Cmd.HelpOption("-h|--help");
                <#= commandFormalName #>Cmd.Description = Strings.<#= commandFormalName #>_Description;
                <#= commandFormalName #>Cmd.OnExecute(() =>
                { // Begin Handler
<#
        bool verbHasOptions = false;
        foreach (XElement option in verb.Descendants())
        {
            if (option.Name == XName.Get("Noun"))
            {
                break;
            }

            if (!verbHasOptions)
            {
#>
                    var args = new <#= commandFormalName #>Args()
                    {
<#
            }

            verbHasOptions = true;
            var optionData = new OptionData(option);
            if (optionData.BaseClass == "Argument")
            {
#>
                        <#= optionData.InitCapsName #> = <#= optionData.FormalName #>.Value,
<#
            }
            else if (optionData.BaseClass == "Option")
            {
                switch (optionData.OptionType)
                {
                    case "SingleValue":
#>
                        <#= optionData.InitCapsName #> = <#= optionData.FormalName #>.Value(),
<#
                        break;
                    case "NoValue":
#>
                        <#= optionData.InitCapsName #> = <#= optionData.FormalName #>.HasValue(),
<#
                        break;
                }
            }
        }

        if (verbHasOptions)
        {
#>
                    };

                    <#= commandFormalName #>Runner.Run(args, getLogger);
                    return 0;
<#
        }
        else
        {
#>
                    app.ShowHelp("<#= commandName #>");
                    return 0;
<#
        }
#>
                }); // End Handler
        }
    }

<#
}
#>}
<#+
public class OptionData
{
    public OptionData(XElement element)
    {
        string elementName = element.Name.LocalName;
        Name = element.Attribute(XName.Get("Name", ""))?.Value;
        LongName = element.Attribute(XName.Get("LongName", ""))?.Value;
        Help = element.Attribute(XName.Get("Help", ""))?.Value;
        if (Help != null) { Help = "Strings." + Help; }
        Shortcut = element.Attribute(XName.Get("Shortcut",""))?.Value;
        IsRequired = element.Attribute(XName.Get("Required", ""))?.Value == "true";

        switch (elementName)
        {
            case "SingleValueOption":
                BaseClass = "Option";
                OptionType = "ArgumentArity.ZeroOrOne";
                break;
            case "SwitchOption":
                BaseClass = "Option";
                OptionType = "ArgumentArity.Zero";
                break;
            case "Value":
                BaseClass = "Option";
                OptionType = "ArgumentArity.ExactlyOne";
                break;
            case "Argument":
                BaseClass = "Argument";
                break;
            case "Example":
                BaseClass = "Example";
                break;
            case "SeeAlso":
                BaseClass = "SeeAlso";
                break;
            default:
                throw new Exception("Unknown Element Type " + element.Name.LocalName);
        }
    }

    public string BaseClass { get; set; }
    public string OptionType { get; set; }
    public string Name { get; set; }
    public string InitCapsName { get { return StringUtilities.InitCaps(Name).Replace("-", ""); } }
    public string LongName { get; set; }
    public string LongNameOrName { get { return LongName != null ? LongName : Name; }}
    public string FormalName { get { return Name.Replace("-",""); } }
    public string Shortcut { get; set; }
    public string Help { get; set; }
    public bool IsRequired { get; set; }
    public string ShortcutString { get { return (HasShortcut? ShortcutName + "|" + FullName : FullName); } }
    public bool HasShortcut { get { return Shortcut != null; } }
    public string ShortcutName { get { return "-" + Shortcut; } }
    public string FullName { get { return "--" + Name.ToLower(); } }

}

public static class StringUtilities
{
    public static string InitCaps(string input)
    {
        if (input == null)
        {
            return null;
        }

        var textInfo = CultureInfo.InvariantCulture.TextInfo;
        var output = textInfo.ToTitleCase(input);

        return output;
    }
}
#>
